DataT <- cbind(time = out$time[ii],T = out$T[ii] + rnorm(sd = 4.5, n = length(ii)),sd = 4.5)
head(DataT)
HIVcost <- function (pars) {
out <- HIV(pars)
cost <- modCost(model = out, obs = DataLogV, err = "sd")
return(modCost(model = out, obs = DataT, err = "sd", cost = cost))
}
HIVcost(pars)$model
plot(HIVcost(pars), xlab="time")
HIVcost(pars)$model
plot(HIVcost(pars), xlab="time")
HIVcost
rm(list=ls())
remove (list = objects() )
library (deSolve)
si_model = function (current_timepoint, state_values, parameters)
{
# create state variables (local variables)
S = state_values [1]        # susceptibles
I = state_values [2]        # infectious
with (
as.list (parameters),     # variable names within parameters can be used
{
# compute derivatives
dS = (-beta * S * I)
dI = ( beta * S * I) - (gamma * I)
# combine results
results = c (dS, dI)
list (results)
}
)
}
contact_rate = 1                     # number of contacts per day
transmission_probability = 0.04       # transmission probability
infectious_period = 800                 # infectious period
beta_value = contact_rate * transmission_probability
gamma_value = 1 / infectious_period
Ro = beta_value / gamma_value
parameter_list = c (beta = beta_value, gamma = gamma_value)
X = 568        # susceptible hosts
Y = 432          # infectious hosts
N = X + Y
initial_values = c (S = X/N, I = Y/N)
timepoints = seq (0, 50, by=1)
output = ode (initial_values, timepoints, si_model, parameter_list)
plot (S ~ time, data = output, type='b', col = 'blue')
plot (I ~ time, data = output, type='b', col = 'red')
# susceptible hosts over time
plot (S ~ time, data = output, type='b', ylim = c(0,1), col = 'blue', ylab = 'S, I', main = 'SI epidemic')
# remain on same frame
par (new = TRUE)
# infectious hosts over time
plot (I ~ time, data = output, type='b', ylim = c(0,1), col = 'red', ylab = '', axes = FALSE)
remove (list = objects() )
library (deSolve)
si_model = function (current_timepoint, state_values, parameters)
{
# create state variables (local variables)
S = state_values [1]        # susceptibles
I = state_values [2]        # infectious
with (
as.list (parameters),     # variable names within parameters can be used
{
# compute derivatives
dS = (-beta * S * I)
dI = ( beta * S * I) - (gamma * I)
# combine results
results = c (dS, dI)
list (results)
}
)
}
contact_rate = 1                     # number of contacts per day
transmission_probability = 0.04       # transmission probability
infectious_period = 800                 # infectious period
beta_value = contact_rate * transmission_probability
gamma_value = 1 / infectious_period
Ro = beta_value / gamma_value
parameter_list = c (beta = beta_value, gamma = gamma_value)
X = 568        # susceptible hosts
Y = 432          # infectious hosts
N = X + Y
initial_values = c (S = X/N, I = Y/N)
timepoints = seq (0, 50, by=1)
output = ode (initial_values, timepoints, si_model, parameter_list)
# susceptible hosts over time
plot (S ~ time, data = output, type='b', ylim = c(0,1), col = 'blue', ylab = 'S, I', main = 'SI epidemic')
# remain on same frame
par (new = TRUE)
# infectious hosts over time
plot (I ~ time, data = output, type='b', ylim = c(0,1), col = 'red', ylab = '', axes = FALSE)
par (new = TRUE)
X = 130000        # susceptible hosts
Y = 8000          # infectious hosts
N = X + Y
initial_values = c (S = X/N, I = Y/N)
timepoints = seq (0, 50, by=1)
output = ode (initial_values, timepoints, si_model, parameter_list)
# susceptible hosts over time
plot (S ~ time, data = output, type='b', ylim = c(0,1), col = 'blue', ylab = 'S, I', main = 'SI epidemic')
# remain on same frame
par (new = TRUE)
# infectious hosts over time
plot (I ~ time, data = output, type='b', ylim = c(0,1), col = 'red', ylab = '', axes = FALSE)
par (new = TRUE)
# susceptible hosts over time
plot (S ~ time, data = output, type='b', ylim = c(0,1), col = 'blue', ylab = 'S, I', main = 'SI epidemic')
# remain on same frame
par (new = TRUE)
# infectious hosts over time
plot (I ~ time, data = output, type='b', ylim = c(0,1), col = 'red', ylab = '', axes = FALSE)
initial_values = c (S = X/N, I = Y/N)
timepoints = seq (1996, 2018, by=1)
output = ode (initial_values, timepoints, si_model, parameter_list)
# susceptible hosts over time
plot (S ~ time, data = output, type='b', ylim = c(0,1), col = 'blue', ylab = 'S, I', main = 'SI epidemic')
# remain on same frame
par (new = TRUE)
# infectious hosts over time
plot (I ~ time, data = output, type='b', ylim = c(0,1), col = 'red', ylab = '', axes = FALSE)
f <- function(x) sin(x) + sin(2 * x) + cos(3 * x)
curve(f, from = 0, to = 2 * pi)
optimize(f, interval = c(0, 2 * pi))
uniroot(f, interval = c(0, 2 * pi))
uniroot(f, interval = c(0, 2 * pi))
uniroot(f, interval = c(0, 2 * pi))
uniroot(f, interval = c(0, 6))
uniroot(f, interval = c(3, 4))$root
uniroot(f, interval = c(3, 4))$root
uniroot(f, interval = c(4, 5))$root
uniroot(f, interval = c(5, 2 * pi))$root
uout <- uniroot(f, interval = c(0, 2 * pi), extendInt = "yes")
uout$root
foo <- read.table("http://www.stat.umn.edu/geyer/5102/data/ex6-1.txt",
header = TRUE)
gout <- glm(y ~ x, data = foo, family = binomial, x = TRUE)
summary(gout)
logl <- function(theta, x, n, deriv = 2) {
stopifnot(is.numeric(theta))
stopifnot(is.finite(theta))
stopifnot(length(theta) == 1)
stopifnot(is.numeric(x))
stopifnot(is.finite(x))
stopifnot(length(x) == 1)
if (x != round(x)) stop("x must be integer")
stopifnot(is.numeric(n))
stopifnot(is.finite(n))
stopifnot(length(n) == 1)
if (n != round(n)) stop("n must be integer")
stopifnot(0 <= x)
stopifnot(x <= n)
stopifnot(length(deriv) == 1)
stopifnot(deriv %in% 0:2)
val <- if (theta < 0) x * theta - n * log1p(exp(theta)) else
- (n - x) * theta - n * log1p(exp(- theta))
result <- list(value = val)
if (deriv == 0) return(result)
pp <- if (theta < 0) exp(theta) / (1 + exp(theta)) else
1 / (exp(- theta) + 1)
qq <- if (theta < 0) 1 / (1 + exp(theta)) else
exp(- theta) / (exp(- theta) + 1)
grad <- if (x < n) x - n * pp else n * qq
result$gradient <- grad
if (deriv == 1) return(result)
result$hessian <- (- n * pp * qq)
return(result)
}
logl.reg <- function(beta) {
stopifnot(length(beta) == ncol(modmat))
stopifnot(is.numeric(beta))
stopifnot(is.finite(beta))
theta <- drop(modmat %*% beta)
sum(logl.vec(theta, resp))
}
crit
conf.level <- 0.95
alpha <- 1 - conf.level
crit <- qchisq(alpha, df = 2, lower.tail = FALSE) / 2
crit
beta.hat <- gout$coefficients
sup.logl.reg <- logl.reg(beta.hat)
phi <- seq(0, 2 * pi, length = 501)
rr <- double(length(phi))
for (i in seq(along = phi)) {
fred <- function(ss) sup.logl.reg - crit -
logl.reg(beta.hat + ss * c(20 * cos(phi[i]), sin(phi[i])))
# 20 above because beta1 has 20 times std. err. of beta2
rr[i] <- uniroot(fred, interval = c(0, 1), extendInt = "upX")$root
}
xx <- beta.hat[1] + rr * 20 * cos(phi)
yy <- beta.hat[2] + rr * sin(phi)
xx <- c(xx, xx[1])
yy <- c(yy, yy[1])
plot(xx, yy, type = "l", xlab = "beta1 (intercept)", ylab = "beta2 (slope)")
points(beta.hat[1], beta.hat[2])
conf.level <- 0.95
alpha <- 1 - conf.level
crit <- qchisq(alpha, df = 2, lower.tail = FALSE) / 2
crit
beta.hat <- gout$coefficients
sup.logl.reg <- logl.reg(beta.hat)
phi <- seq(0, 2 * pi, length = 501)
rr <- double(length(phi))
modmat <- gout$x
resp <- gout$y
logl.noderiv <- function(theta, y) logl(theta, y, n = 1, deriv = 0)$value
logl.vec <- Vectorize(logl.noderiv)
logl.reg <- function(beta) {
stopifnot(length(beta) == ncol(modmat))
stopifnot(is.numeric(beta))
stopifnot(is.finite(beta))
theta <- drop(modmat %*% beta)
sum(logl.vec(theta, resp))
}
conf.level <- 0.95
alpha <- 1 - conf.level
crit <- qchisq(alpha, df = 2, lower.tail = FALSE) / 2
crit
beta.hat <- gout$coefficients
sup.logl.reg <- logl.reg(beta.hat)
phi <- seq(0, 2 * pi, length = 501)
rr <- double(length(phi))
for (i in seq(along = phi)) {
fred <- function(ss) sup.logl.reg - crit -
logl.reg(beta.hat + ss * c(20 * cos(phi[i]), sin(phi[i])))
# 20 above because beta1 has 20 times std. err. of beta2
rr[i] <- uniroot(fred, interval = c(0, 1), extendInt = "upX")$root
}
xx <- beta.hat[1] + rr * 20 * cos(phi)
yy <- beta.hat[2] + rr * sin(phi)
xx <- c(xx, xx[1])
yy <- c(yy, yy[1])
plot(xx, yy, type = "l", xlab = "beta1 (intercept)", ylab = "beta2 (slope)")
points(beta.hat[1], beta.hat[2])
points(beta.hat[1], beta.hat[2])
plot(xx, yy, type = "l", xlab = "beta1 (intercept)", ylab = "beta2 (slope)")
points(beta.hat[1], beta.hat[2])
rm(list=ls())
help(GenSA)
help(gensa)
HIV <- function(time, state_values, parameters) {
Ym = state_values [1]        # over 15 years-old men
Yw = state_values [2]        # over 15 years-old women
Ymsm = state_values [3]      # over 15 years-old MSM
IUm = state_values [4]       # over 15 years-old infected men
IDm = state_values [5]
IUw = state_values [6]       # over 15 years-old infected women
IDw = state_values [7]
IUmsm = state_values [8]        # over 15 years-old MSM
IDmsm = state_values [9]
D = state_values [7]        # Death
with(as.list(c(state_values, parameters)), {
dYm<-M-(1-e2)*alpha*Ym-(1-p2)*(1-e1)*(1-e4)*beta*(((V+1)*IUw)/((V+1)*IUw+Yw))*Ym-d_m*Ym
dYw<- W-(1-p2)*(1-e1)*(1-e4)*gamma*(((V+1)*IUm)/((V+1)*IUm+Ym))*Yw-d_w*Ym
dYmsm<-(1-e2)*alpha*Ym-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*(((V+1)*IUmsm)/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*Ymsm
dIUm<-(1-p2)*(1-e1)*(1-e4)*beta*(IUw/((V+1)*IUw+Yw))*Ym-d_m*IUm
dIDm<-(1-p2)*(1-e1)*(1-e4)*beta*((V*IUw)/((V+1)*IUw+Yw))*Ym-d_m*V*IUm
dIUw<-(1-p2)*(1-e1)*(1-e4)*gamma*(IUm/((V+1)*IUm+Ym))*Yw-d_w*IUw
dIDw<-(1-p2)*(1-e1)*(1-e4)*gamma*((V*IUm)/((V+1)*IUm+Yw))*Yw-d_w*V*IUw
dIUmsm<-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*(IUmsm/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*IUmsm
dIDmsm<-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*((V*IUmsm)/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*V*IUmsm
dD <- d_m*Ym+d_w*Yw+d_m*Ymsm+d_m*IUm+d_m*V*IUm+d_w*IUw +d_w*V*IUw+d_m*IUmsm+d_m*V*IUmsm
return(list(c(dYm, dYw, dYmsm, dIUm, dIDm, dIUw, dIDw, dIUmsm, dIDmsm, dD)))
})
}
parameters <- c(alpha= parameters[1], beta = parameters[2], gamma = parameters[4], epsillon=parameters[5], e1=0,e2=0,e3=0,e4=0,p1=0,p2=0,d_m=0.006868651,d_w=0.005817024,M=223322+151489,W=210682+127508,V = parameters[6])
init<- c(Ym = 24756708, Yw=24672998, Ymsm = 124406, IUm = 1400, IDm = 2000 , IUw = 1800 ,IDw = 3000, IUmsm =7700,IUmsm =11000,)
sir_1 <- function(parameters) {
require(deSolve) # for the "ode" function
# the differential equations:
HIV <- function(time, state_values, parameters) {
Ym = state_values [1]        # over 15 years-old men
Yw = state_values [2]        # over 15 years-old women
Ymsm = state_values [3]      # over 15 years-old MSM
IUm = state_values [4]       # over 15 years-old infected men
IDm = state_values [5]
IUw = state_values [6]       # over 15 years-old infected women
IDw = state_values [7]
IUmsm = state_values [8]        # over 15 years-old MSM
IDmsm = state_values [9]
D = state_values [7]        # Death
with(as.list(c(state_values, parameters)), {
dYm<-M-(1-e2)*alpha*Ym-(1-p2)*(1-e1)*(1-e4)*beta*(((V+1)*IUw)/((V+1)*IUw+Yw))*Ym-d_m*Ym
dYw<- W-(1-p2)*(1-e1)*(1-e4)*gamma*(((V+1)*IUm)/((V+1)*IUm+Ym))*Yw-d_w*Ym
dYmsm<-(1-e2)*alpha*Ym-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*(((V+1)*IUmsm)/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*Ymsm
dIUm<-(1-p2)*(1-e1)*(1-e4)*beta*(IUw/((V+1)*IUw+Yw))*Ym-d_m*IUm
dIDm<-(1-p2)*(1-e1)*(1-e4)*beta*((V*IUw)/((V+1)*IUw+Yw))*Ym-d_m*V*IUm
dIUw<-(1-p2)*(1-e1)*(1-e4)*gamma*(IUm/((V+1)*IUm+Ym))*Yw-d_w*IUw
dIDw<-(1-p2)*(1-e1)*(1-e4)*gamma*((V*IUm)/((V+1)*IUm+Yw))*Yw-d_w*V*IUw
dIUmsm<-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*(IUmsm/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*IUmsm
dIDmsm<-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*((V*IUmsm)/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*V*IUmsm
dD <- d_m*Ym+d_w*Yw+d_m*Ymsm+d_m*IUm+d_m*V*IUm+d_w*IUw +d_w*V*IUw+d_m*IUmsm+d_m*V*IUmsm
return(list(c(dYm, dYw, dYmsm, dIUm, dIDm, dIUw, dIDw, dIUmsm, dIDmsm, dD)))
})
}
# the parameters values:
parameters <- c(alpha= parameters[1], beta = parameters[2], gamma = parameters[4], epsillon=parameters[5],
e1=0,e2=0,e3=0,e4=0,p1=0,p2=0,d_m=0.006868651,d_w=0.005817024,M=223322+151489,W=210682+127508,V = parameters[6])
init<- c(Ym = 24756708, Yw=24672998, Ymsm = 124406, IUm = 1400, IDm = 2000 , IUw = 1800 ,IDw = 3000, IUmsm =7700,IUmsm =11000,)
ou1 <- as.data.frame(ode(init, seq(2010, 2015, by = 1), HIV,  parameters))
# returning the output:
as.data.frame(out)
}
# the differential equations:
HIV <- function(time, state_values, parameters) {
with(as.list(c(state_values, parameters)), {
dYm<-M-(1-e2)*alpha*Ym-(1-p2)*(1-e1)*(1-e4)*beta*(((V+1)*IUw)/((V+1)*IUw+Yw))*Ym-d_m*Ym
dYw<- W-(1-p2)*(1-e1)*(1-e4)*gamma*(((V+1)*IUm)/((V+1)*IUm+Ym))*Yw-d_w*Ym
dYmsm<-(1-e2)*alpha*Ym-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*(((V+1)*IUmsm)/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*Ymsm
dIUm<-(1-p2)*(1-e1)*(1-e4)*beta*(IUw/((V+1)*IUw+Yw))*Ym-d_m*IUm
dIDm<-(1-p2)*(1-e1)*(1-e4)*beta*((V*IUw)/((V+1)*IUw+Yw))*Ym-d_m*V*IUm
dIUw<-(1-p2)*(1-e1)*(1-e4)*gamma*(IUm/((V+1)*IUm+Ym))*Yw-d_w*IUw
dIDw<-(1-p2)*(1-e1)*(1-e4)*gamma*((V*IUm)/((V+1)*IUm+Yw))*Yw-d_w*V*IUw
dIUmsm<-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*(IUmsm/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*IUmsm
dIDmsm<-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*((V*IUmsm)/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*V*IUmsm
dD <- d_m*Ym+d_w*Yw+d_m*Ymsm+d_m*IUm+d_m*V*IUm+d_w*IUw +d_w*V*IUw+d_m*IUmsm+d_m*V*IUmsm
return(list(c(dYm, dYw, dYmsm, dIUm, dIDm, dIUw, dIDw, dIUmsm, dIDmsm, dD)))
})
}
sqr(4)
# the differential equations:
HIV <- function(time, state_values, parameters) {
with(as.list(c(state_values, parameters)), {
dYm<-M-(1-e2)*alpha*Ym-(1-p2)*(1-e1)*(1-e4)*beta*(((V+1)*IUw)/((V+1)*IUw+Yw))*Ym-d_m*Ym
dYw<- W-(1-p2)*(1-e1)*(1-e4)*gamma*(((V+1)*IUm)/((V+1)*IUm+Ym))*Yw-d_w*Ym
dYmsm<-(1-e2)*alpha*Ym-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*(((V+1)*IUmsm)/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*Ymsm
dIUm<-(1-p2)*(1-e1)*(1-e4)*beta*(IUw/((V+1)*IUw+Yw))*Ym-d_m*IUm
dIDm<-(1-p2)*(1-e1)*(1-e4)*beta*((V*IUw)/((V+1)*IUw+Yw))*Ym-d_m*V*IUm
dIUw<-(1-p2)*(1-e1)*(1-e4)*gamma*(IUm/((V+1)*IUm+Ym))*Yw-d_w*IUw
dIDw<-(1-p2)*(1-e1)*(1-e4)*gamma*((V*IUm)/((V+1)*IUm+Yw))*Yw-d_w*V*IUw
dIUmsm<-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*(IUmsm/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*IUmsm
dIDmsm<-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*((V*IUmsm)/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*V*IUmsm
return(list(c(dYm, dYw, dYmsm, dIUm, dIDm, dIUw, dIDw, dIUmsm, dIDmsm)))
})
}
parameters <- c(alpha= parameters[1], beta = parameters[2], gamma = parameters[4], epsillon=parameters[5],
e1=0,e2=0,e3=0,e4=0,p1=0,p2=0,d_m=0.006868651,d_w=0.005817024,M=223322+151489,W=210682+127508,V = parameters[6])
init<- c(Ym = 24756708, Yw=24672998, Ymsm = 124406, IUm = 1400, IDm = 2000 , IUw = 1800 ,IDw = 3000, IUmsm =7700,IUmsm =11000)
time <-seq(2010,2015,1)
HIV.model = function(data, parameters){
Ym0 <- as.vector(data$Ym)
Yw0 <- as.vector(data$Yw)
Ymsm0 <- as.vector(data$G)
IUM0 <- as.vector(data$IM)
IDM0 <- as.vector(data$IM)
IUW0 <- as.vector(data$IW)
IDW0 <- as.vector(data$IW)
IUmsm0 <- as.vector(data$IG)
IDmsm0 <- as.vector(data$IG)
parameters <- c(alpha= parameters[1], beta = parameters[2], gamma = parameters[4], epsillon=parameters[5],
e1=0,e2=0,e3=0,e4=0,p1=0,p2=0,d_m=0.006868651,d_w=0.005817024,M=223322+151489,W=210682+127508,V = parameters[6])
init<- c(Ym = 24756708, Yw=24672998, Ymsm = 124406, IUm = 1400, IDm = 2000 , IUw = 1800 ,IDw = 3000, IUmsm =7700,IUmsm =11000)
time <-seq(2010,2015,1)
Ym0_predicted <- as.vector(ode(init, time, HIV,parameters)[,2])
Yw0_predicted <- as.vector(ode(init, time, HIV,parameters)[,3])
Ymsm0_predicted <- as.vector(ode(init, time, HIV,parameters)[,4])
IUM0_predicted <- as.vector(ode(init, time, HIV,parameters)[,5])
IDM0_predicted <- as.vector(ode(init, time, HIV,parameters)[,6])
IUW0_predicted <- as.vector(ode(init, time, HIV,parameters)[,7])
IDW0_predicted <- as.vector(ode(init, time, HIV,parameters)[,8])
Imss0_predicted <- as.vector(ode(init, time, HIV,parameters)[,9])
RMSE1<- sqrt(sum((IM0 - IM0_predicted)^2)/length(data$year))
return(RMSE1)
}
# the differential equations:
HIV <- function(time, state_values, parameters) {
with(as.list(c(state_values, parameters)), {
dYm<-M-(1-e2)*alpha*Ym-(1-p2)*(1-e1)*(1-e4)*beta*(((V+1)*IUw)/((V+1)*IUw+Yw))*Ym-d_m*Ym
dYw<- W-(1-p2)*(1-e1)*(1-e4)*gamma*(((V+1)*IUm)/((V+1)*IUm+Ym))*Yw-d_w*Ym
dYmsm<-(1-e2)*alpha*Ym-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*(((V+1)*IUmsm)/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*Ymsm
dIUm<-(1-p2)*(1-e1)*(1-e4)*beta*(IUw/((V+1)*IUw+Yw))*Ym-d_m*IUm
dIDm<-(1-p2)*(1-e1)*(1-e4)*beta*((V*IUw)/((V+1)*IUw+Yw))*Ym-d_m*V*IUm
dIUw<-(1-p2)*(1-e1)*(1-e4)*gamma*(IUm/((V+1)*IUm+Ym))*Yw-d_w*IUw
dIDw<-(1-p2)*(1-e1)*(1-e4)*gamma*((V*IUm)/((V+1)*IUm+Yw))*Yw-d_w*V*IUw
dIUmsm<-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*(IUmsm/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*IUmsm
dIDmsm<-(1-p1)*(1-e1)*(1-e3)*(1-e4)*epsillon*((V*IUmsm)/((V+1)*IUmsm+Ymsm))*Ymsm-d_m*V*IUmsm
return(list(c(dYm, dYw, dYmsm, dIUm, dIDm, dIUw, dIDw, dIUmsm, dIDmsm)))
})
}
HIV.model = function(data, parameters){
Ym0 <- as.vector(data$Ym)
Yw0 <- as.vector(data$Yw)
Ymsm0 <- as.vector(data$G)
IUM0 <- as.vector(data$IM)
IDM0 <- as.vector(data$IM)
IUW0 <- as.vector(data$IW)
IDW0 <- as.vector(data$IW)
IUmsm0 <- as.vector(data$IG)
IDmsm0 <- as.vector(data$IG)
parameters <- c(alpha= parameters[1], beta = parameters[2], gamma = parameters[4], epsillon=parameters[5],
e1=0,e2=0,e3=0,e4=0,p1=0,p2=0,d_m=0.006868651,d_w=0.005817024,M=223322+151489,W=210682+127508,V = parameters[6])
init<- c(Ym = 24756708, Yw=24672998, Ymsm = 124406, IUm = 1400, IDm = 2000 , IUw = 1800 ,IDw = 3000, IUmsm =7700,IUmsm =11000)
time <-seq(2010,2015,1)
Ym0_predicted <- as.vector(ode(init, time, HIV,parameters)[,2])
Yw0_predicted <- as.vector(ode(init, time, HIV,parameters)[,3])
Ymsm0_predicted <- as.vector(ode(init, time, HIV,parameters)[,4])
IUM0_predicted <- as.vector(ode(init, time, HIV,parameters)[,5])
IDM0_predicted <- as.vector(ode(init, time, HIV,parameters)[,6])
IUW0_predicted <- as.vector(ode(init, time, HIV,parameters)[,7])
IDW0_predicted <- as.vector(ode(init, time, HIV,parameters)[,8])
Imss0_predicted <- as.vector(ode(init, time, HIV,parameters)[,9])
RMSE1<- sqrt(sum((IM0 - IM0_predicted)^2)/length(data$year))
return(RMSE1)
}
setwd("~/Desktop/Document/GitHub/Mathematical_Modleing")
setwd("~/Desktop/Document/GitHub/Mathematical-Modleing")
setwd("~/Desktop/Document/GitHub/Mathematical-modeling/")
setwd("~/Desktop/Document/GitHub/Mathematical-modeling")
setwd("~/Desktop/Documents/GitHub/Mathematical-modeling")
setwd("~/Desktop/Documents/GitHub/Mathematical-modeling/")
setwd("~/Desktop/Documents/GitHub/Mathematical-modeling")
setwd("~/Desktop/Documents/GitHub/Mathematical-modeling/")
setwd("~/Documents/GitHub/Mathematical-modeling")
setwd("~/Documents/GitHub/Mathematical-modeling")
library(readr)
data <- read_csv("data.csv")
data<-as.data.frame(data)
setwd("~/Documents/GitHub/Mathematical-modeling")
library(readr)
data <- read_csv("data.csv")
data<-as.data.frame(data)
data
new.seed = as.integer(runif(1)*2e9)
cat("Random seed: ", new.seed, "\n")
set.seed(new.seed)
par = runif(6)
min.global = 0      # Expected global minimum
tol = 1e-13         # Tolerance
dimension=6
#
lower <- rep(0.000000001,dimension)
upper <- rep(0.999999999,dimension)
library(GenSA)
library(deSolve)
out <- GenSA(par = par, lower = lower, upper = upper, fn = HIV.model, data = data,
control=list(threshold.stop=min.global+tol,
verbose=FALSE))
HIV.model = function(data, parameters){
Ym0 <- as.vector(data[,2])
Yw0 <- as.vector(data[,3])
Ymsm0 <- as.vector(data[,4])
IUM0 <- as.vector(data[,5])
IDM0 <- as.vector(data[,6])
IUW0 <- as.vector(data[,7])
IDW0 <- as.vector(data[,8])
IUmsm0 <- as.vector(data[,9])
IDmsm0 <- as.vector(data[,10])
parameters <- c(alpha= parameters[1], beta = parameters[2], gamma = parameters[4], epsillon=parameters[5],
e1=0,e2=0,e3=0,e4=0,p1=0,p2=0,d_m=0.006868651,d_w=0.005817024,M=223322+151489,W=210682+127508,V = parameters[6])
init<- c(Ym = 24756708, Yw=24672998, Ymsm = 124406, IUm = 1400, IDm = 2000 , IUw = 1800 ,IDw = 3000, IUmsm =7700,IUmsm =11000)
time <-seq(2010,2015,1)
Ym0_predicted <- as.vector(ode(init, time, HIV,parameters)[,2])
Yw0_predicted <- as.vector(ode(init, time, HIV,parameters)[,3])
Ymsm0_predicted <- as.vector(ode(init, time, HIV,parameters)[,4])
IUM0_predicted <- as.vector(ode(init, time, HIV,parameters)[,5])
IDM0_predicted <- as.vector(ode(init, time, HIV,parameters)[,6])
IUW0_predicted <- as.vector(ode(init, time, HIV,parameters)[,7])
IDW0_predicted <- as.vector(ode(init, time, HIV,parameters)[,8])
IUmsm0_predicted <- as.vector(ode(init, time, HIV,parameters)[,9])
IDmsm0_predicted <- as.vector(ode(init, time, HIV,parameters)[,10])
RMSE1<- sqrt(sum((IM0 - IM0_predicted)^2)/length(data$year))
return(RMSE1)
}
setwd("~/Documents/GitHub/Mathematical-modeling")
library(readr)
data <- read_csv("data.csv")
data<-as.data.frame(data)
data
new.seed = as.integer(runif(1)*2e9)
cat("Random seed: ", new.seed, "\n")
set.seed(new.seed)
par = runif(6)
min.global = 0      # Expected global minimum
tol = 1e-13         # Tolerance
dimension=6
#
lower <- rep(0.000000001,dimension)
upper <- rep(0.999999999,dimension)
library(GenSA)
library(deSolve)
out <- GenSA(par = par, lower = lower, upper = upper, fn = HIV.model, data = data,
control=list(threshold.stop=min.global+tol,
verbose=FALSE))
HIV.model = function(data, parameters){
Ym0 <- as.vector(data[,2])
Yw0 <- as.vector(data[,3])
Ymsm0 <- as.vector(data[,4])
IUM0 <- as.vector(data[,5])
IDM0 <- as.vector(data[,6])
IUW0 <- as.vector(data[,7])
IDW0 <- as.vector(data[,8])
IUmsm0 <- as.vector(data[,9])
IDmsm0 <- as.vector(data[,10])
parameters <- c(alpha= parameters[1], beta = parameters[2], gamma = parameters[4], epsillon=parameters[5],
e1=0,e2=0,e3=0,e4=0,p1=0,p2=0,d_m=0.006868651,d_w=0.005817024,M=223322+151489,W=210682+127508,V = parameters[6])
init<- c(Ym = 24756708, Yw=24672998, Ymsm = 124406, IUm = 1400, IDm = 2000 , IUw = 1800 ,IDw = 3000, IUmsm =7700,IUmsm =11000)
time <-seq(2010,2015,1)
Ym0_predicted <- as.vector(ode(init, time, HIV,parameters)[,2])
Yw0_predicted <- as.vector(ode(init, time, HIV,parameters)[,3])
Ymsm0_predicted <- as.vector(ode(init, time, HIV,parameters)[,4])
IUM0_predicted <- as.vector(ode(init, time, HIV,parameters)[,5])
IDM0_predicted <- as.vector(ode(init, time, HIV,parameters)[,6])
IUW0_predicted <- as.vector(ode(init, time, HIV,parameters)[,7])
IDW0_predicted <- as.vector(ode(init, time, HIV,parameters)[,8])
IUmsm0_predicted <- as.vector(ode(init, time, HIV,parameters)[,9])
IDmsm0_predicted <- as.vector(ode(init, time, HIV,parameters)[,10])
RMSE1<- sqrt(sum((IDM0 - IDM0_predicted)^2)/length(data$year))
return(RMSE1)
}
out <- GenSA(par = par, lower = lower, upper = upper, fn = HIV.model, data = data,
control=list(threshold.stop=min.global+tol,
verbose=FALSE))
